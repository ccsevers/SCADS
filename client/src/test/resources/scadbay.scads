/**
 * Scadbay SCADS definition file
 * Author : Stephen Tu
 * Date   : 9-17-09
 */

/* NOTE: long comments are broken up un-naturally because the scala
 * parser cannot handle very long comments for now without overflowing
 * the stack (perhaps we need to increase stack size) */

/* -------- BEGIN ENTITY TYPES --------- */

ENTITY user
{
    int    id,
    string email,
    string password,
    string nickname,
    int    datejoined,
    bool   active
    PRIMARY(id)
}

ENTITY item
{
    int    id,
    int    dateposted, /* unix timestamp */
    int    duration,   /* seconds */
    bool   isFinished, /* NOTE: normally this field isn't even needed,
                        * but the problem is, since we don't have any
                        * addition operator nor any comparsions,
                        * let's just have the application logic magically
                        * "handle" this for now so we can write some
                        * queries! */
    string title,
    int    startingprice,
    int    minimumbetraise,
    int    instantbuyprice,
    string pictureurl,
    string description,
    string shortdesc
    PRIMARY(id)
}

ENTITY itemwatch
{
    int id,
    int startdate
    PRIMARY(id)
}

ENTITY autobid
{
    int id,
    int maxamount
    PRIMARY(id)
}

ENTITY brand
{
    int    id,
    string name
    PRIMARY(id)
}


ENTITY parentcategory
{
    string title
    PRIMARY(title)
}

ENTITY regularcategory
{
    string title
    PRIMARY(title)
}

ENTITY categorymap
{
    int id
    PRIMARY(id)
}

ENTITY bid
{
    int id,
    int bidamount,
    int bidtime /* the timestamp of when the bid was placed */
    PRIMARY(id)
}

ENTITY comment
{
    int    id,
    int    rating, /* 1,2,3,4, or 5 stars */
    int    dateposted,
    bool   wouldrecommend,
    string comment,
    int    commenttype /* 1:from buyer to seller, 2:from seller to buyer */
    PRIMARY(id)
}

/* -------- BEGIN RELATIONSHIPS --------- */

RELATIONSHIP myItemsSelling FROM user TO 1000 item

RELATIONSHIP myItemsWatching FROM user TO 100 itemwatch
RELATIONSHIP myItemsWatchingTarget FROM item TO 1 itemwatch

RELATIONSHIP myBids FROM user TO 10000 bid
RELATIONSHIP myBidsTarget FROM item TO 1 bid

/* As a Buyer/Seller, I can leave up to 10000 total comments
 * to Sellers/Buyers */
RELATIONSHIP commentsFromUser FROM user TO 10000 comment
RELATIONSHIP commentsToUser FROM user TO 1 comment
/* Item context for comment */
RELATIONSHIP commentToItem FROM item TO 1 comment
/* Brand of item */
RELATIONSHIP itemBrand FROM item TO MANY brand

RELATIONSHIP itemCategories FROM item TO 10 categorymap
RELATIONSHIP itemCategoriesTarget FROM regularcategory TO 1 categorymap

/* I can have up to 100 autobidders doing my bidding, but
 * each autobidder must only map to one item */
RELATIONSHIP myAutoBids FROM user TO 100 autobid
RELATIONSHIP autobidToItem FROM item TO 1 autobid

/* There are 2 kinds of categories, parents and regular */
RELATIONSHIP parentCategoryMapping FROM parentcategory TO MANY regularcategory

/* -------- BEGIN QUERIES --------- */

/* items I am currently selling */
QUERY myActiveSellingItems
FETCH item
    OF user me BY myItemsSelling
WHERE me=[this] AND item.isFinished = false
ORDER BY dateposted
//PAGINATE [1:numperpage] MAX 50

/* items I am currently bidding on */
QUERY myActiveBiddingItems
FETCH item
    OF bid BY myBidsTarget
    OF user BY myBids
WHERE user=[this] AND item.isFinished = false
ORDER BY dateposted
//LIMIT [1:count] MAX 100

/* As a seller, the comments that my buyers have left for me */
QUERY myCommentsAsSeller
FETCH comment
    OF user BY commentsToUser
WHERE user=[this]
AND comment.commenttype = 1 /* 1: from buyer to seller */
ORDER BY dateposted

/* As a buyer, the comments that my sellers have left for me */
QUERY myCommentsAsBuyer
FETCH comment
    OF user BY commentsToUser
WHERE user=[this]
AND comment.commenttype = 2 /* 1: from buyer to seller */
ORDER BY dateposted

/* All the comments I have left for my buyers/sellers */
QUERY myPostedComments
FETCH comment
    OF user BY commentsFromUser
WHERE user=[this]
ORDER BY dateposted

/* Autobidders of an item
 * This might be useful for a daemon process that does auto-bidding */
QUERY itemAutoBidders
FETCH autobid
    OF item BY autobidToItem
WHERE item=[this]

/* all active items under a certain sub-parent category (by title) */
/*
QUERY activeItemsByParentCategory
FETCH item
    OF regularcategory regular BY itemCategories
    OF parentcategory parent BY parentCategoryMapping
WHERE parent.title=[1:title] AND
item.isFinished = false
ORDER BY dateposted
*/

/* all active items under a certain regular category (by title)
QUERY activeItemsByRegularCategory
FETCH item
    OF regularcategory regular BY itemCategories
WHERE regular.title=[1:title] AND
item.isFinished = false
ORDER BY dateposted */

/* all top-level parent categories */
QUERY allParentCategories
FETCH parentcategory
ORDER BY parentcategory.title

/* items in a particular brand (by brand name) */
QUERY allBrandItems
FETCH item
    OF brand BY itemBrand
WHERE brand.name=[1:name]
ORDER BY dateposted

/* top bid on item (current price of an item)
 * Techically, this is the lowestItemBid, but pretend we had a DESC
 * ORDER BY predicate option (that is, assuming ORDER BY was ascending
 * by default) */
QUERY topItemBid
FETCH bid
    OF item BY myBidsTarget
WHERE item=[this]
ORDER BY dateposted DESC
//LIMIT 1 MAX 100 // what does the MAX in a LIMIT do? I always want 1 result!

QUERY finduserByPK
FETCH user
WHERE id = [1:id]


/* Queries that need other features to do:
 1) the average rating of a seller
 2) the number of ratings of a seller
 3) the highest rated seller
 4) my bids in the last 5 days
 5) items that are closing in the next N minutes
 6) the category of items I have the most bids in
 7) average number of times I bid on items
 */
