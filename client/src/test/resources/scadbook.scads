/**
 * Scadbook SCADS definition file (r1)
 * Author : Stephen Tu
 * Date   : 9-17-09
 */

/* -------- BEGIN ENTITY TYPES --------- */

/*
 * Note: SCADS doesn't currently have a Date type, so we use
 * int types for now to represent (Unix timestamp)
 */

/*
 * User Entity:
 * This represents a user in the system
 */
ENTITY user
{
    int    id,
    string email,
    string password,
    string nickname,
    int    datejoined,
    bool   active
    PRIMARY(id)
}

/*
 * Profile Entity:
 * This represents a limited user profile in the system
 * Note that this is limited in that, every time a new profile
 * attribute needs to be added, a column needs to be created,
 * in addition to not allowing any lists of data (all key-value
 * pairs must have scalar values).
 */
ENTITY profile
{
    int    id,
    int    birthday,
    string hometown,
    string sex,
    string politicalaffiliation,
    string interests,
    string activities
    PRIMARY(id)
}


/*
 * Network Entity:
 * This represents a network that users can belong to
 * For now, the type is represented as an integer (mapping
 * to be stored elsewhere).
 */
ENTITY network
{
    int    id,
    int    networkType, /* regional, high school, college */
    string name
    PRIMARY(id)
}

ENTITY networksubscription
{
    int id,
    int datejoined
    PRIMARY(id)
}

ENTITY wallpost
{
    int    id,
    int    dateposted,
    string contents
    PRIMARY(id)
}

ENTITY friendship
{
    int id,
    bool approved
    PRIMARY(id)
}

ENTITY group
{
    int    id,
    int    groupType, /* enum for now */
    string name
    PRIMARY(id)
}

ENTITY groupsubscription
{
    int id,
    int datejoined
    PRIMARY(id)
}

/* Poke Entity:
 * Pokes don't really need any additional metadata
 * i.e., I don't realy care when you poked me, but
 * with the current SCADS model, I believe this is
 * necessary
 */
ENTITY poke
{
    int  id,
    bool hidden
    PRIMARY(id)
}

/* -------- BEGIN RELATIONSHIP DEFINITIONS --------- */

/* A user has one profile, and the user is the owner of the 1 TO 1 */
RELATIONSHIP userProfile FROM profile TO ONE user

/* A user can be a part of up to 20 networks (some reasonable cap) */
RELATIONSHIP networks FROM user TO 20 networksubscription
RELATIONSHIP networktarget FROM network TO ONE networksubscription

/* A wallpost can be from a user */
RELATIONSHIP wallpostsFromUser FROM user TO MANY wallpost

/* A wallpost can also be directed towards a user */
RELATIONSHIP wallpostsToUser FROM user TO ONE wallpost

/* A user can have up to 5000 friends */
/* NOTE: We make the assumption that friendships will be maintained
 * bi-directionally in the application logic
 */
RELATIONSHIP friendships FROM user TO 5000 friendship
RELATIONSHIP friendshiptarget FROM user TO ONE friendship

/* A user can belong to 1000 groups */
RELATIONSHIP groups FROM user TO 1000 groupsubscription
RELATIONSHIP grouptarget FROM group TO ONE groupsubscription

/* A user can post on a group wall */
RELATIONSHIP wallpostsToGroup FROM group TO ONE wallpost

/* A user can initiate many pokes */
RELATIONSHIP pokes FROM user TO MANY poke

/* But each poke can only be targeted to one user */
RELATIONSHIP poketarget FROM user TO ONE poke

/*
 * NOTE:
 * The wallposts/friendships/and pokes concepts all have the same
 * basic model.
 */

/* -------- BEGIN QUERY DEFINITIONS --------- */
QUERY myNetworks
FETCH network
    OF networksubscription BY networktarget
    OF user BY networks
WHERE user=[this]
ORDER BY networkType

QUERY postsOnMyWall
FETCH wallpost
    OF user me BY wallpostsToUser
WHERE me=[this]
ORDER BY dateposted

QUERY myPostsOnOtherWalls
FETCH wallpost
    OF user me BY wallpostsFromUser
WHERE me=[this]
ORDER BY dateposted

/* NOTE: WallToWall(a,b) is then generated by calling this query twice
 * (i.e. myPostsOnUserWall(1:a,2:b) and then myPostsOnUserWall(1:b,2:a))
 * and interleaving them together by date

QUERY myPostsOnUserWall
FETCH wallpost
    OF user me BY wallpostsFromUser
    OF user other BY wallpostsToUser
WHERE
    me = [this] AND other.id = [1:otherid]
ORDER BY dateposted*/

/* NOTE: We use the assumption that all approved friendships are
 * bi-directional, ie if you are my friend then I am your friend
 */
QUERY myFriends
FETCH user
    OF friendship BY friendshiptarget
    OF user me BY friendships
WHERE me=[this] AND friendship.approved = true

/* I don't think the query is doing what we want
QUERY myFriendsInNetwork
FETCH user
    OF friendship BY target
    OF user me BY friendships
    OF network nw BY networks
WHERE
    me=[this] AND
    nw=[1:network] AND
    friendship.approved = true
*/

QUERY pendingFriendRequests
FETCH user
    OF friendship BY friendships
    OF user me BY friendshiptarget
WHERE me=[this] AND friendship.approved = false

QUERY myGroups
FETCH group
    OF groupsubscription BY grouptarget
    OF user BY groups
WHERE user=[this]

QUERY usersInGroup
FETCH user
    OF groupsubscription BY groups
    OF group BY grouptarget
WHERE group=[this]

QUERY groupWall
FETCH wallpost
    OF group g BY wallpostsToGroup
WHERE g=[this]

QUERY myPokedBy
FETCH user
    OF poke BY pokes
    OF user me BY poketarget
WHERE me=[this] AND poke.hidden = false

QUERY finduserByPK
FETCH user
WHERE id = [1:id]

/*
 * Missing Queries
 */
// 1) Friend's birthdays for today
// Need range predicates (ie date <= [time]) to do this, since we
// are using ints to store dates

// 2) Friend count
// Need aggregates

// 3) Mutual Friends
// I'm not sure how we can do this with the current tools

// 4) Friends in my network
// How do we do this without any inner sub-queries?
