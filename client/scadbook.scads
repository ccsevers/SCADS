/**
 * Scadbook SCADS definition file (r1)
 * Author : Stephen Tu
 * Date   : 9-17-09
 */

/* -------- BEGIN ENTITY TYPES --------- */

/*
 * Note: SCADS doesn't currently have a Date type, so we use
 * int types for now to represent (Unix timestamp)
 */

/*
 * User Entity: 
 * This represents a user in the system
 */
ENTITY user
{
    int    id,
    string email,
    string password,
    string nickname,
    int    datejoined,
    bool   active
    PRIMARY(id)
}

/*
 * Profile Entity: 
 * This represents a limited user profile in the system
 * Note that this is limited in that, every time a new profile
 * attribute needs to be added, a column needs to be created, 
 * in addition to not allowing any lists of data (all key-value
 * pairs must have scalar values).
 */
ENTITY profile
{
    int    id,
    int    birthday,
    string hometown,
    string sex,
    string politicalaffiliation,
    string interests,
    string activites
    PRIMARY(id)
}


/*
 * Network Entity: 
 * This represents a network that users can belong to
 * For now, the type is represented as an integer (mapping
 * to be stored elsewhere).
 */
ENTITY network
{
    int    id,
    int    type, /* regional, high school, college */
    string name
    PRIMARY(id)
}

ENTITY wallpost
{
    int    id,
    int    dateposted,
    string contents
    PRIMARY(id)
}

ENTITY friendship
{
    bool approved
    PRIMARY(approved)
}

ENTITY group
{
    int    id,
    int    type, /* enum for now */
    string name
    PRIMARY(id)
}

/* Poke Entity:
 * Pokes don't really need any additional metadata 
 * i.e., I don't realy care when you poked me, but
 * with the current SCADS model, I believe this is 
 * necessary
 */
ENTITY poke
{
    int  id,
    bool hidden
    PRIMARY(id)
}

/* -------- BEGIN RELATIONSHIP DEFINITIONS --------- */

/* A user can be a part of up to 20 networks (some reasonable cap) */
RELATIONSHIP networks FROM user TO 20 network

/* A wallpost can be from a user */
RELATIONSHIP wallpostsFromUser FROM user TO MANY wallpost

/* A wallpost can also be directed towards a user */
RELATIONSHIP wallpostsToUser FROM wallpost TO MANY user

/* A user can have up to 5000 friends */
/* NOTE: We make the assumption that friendships will be maintained
 * bi-directionally in the application logic 
 */
RELATIONSHIP friendships FROM user TO 5000 friendship
RELATIONSHIP target FROM friendship TO ONE user

/* A user can belong to 1000 groups */
RELATIONSHIP groups FROM user TO 1000 group

/* A user can post on a group wall */
RELATIONSHIP wallpostsToGroup FROM wallpost TO MANY group

/* A user can initiate many pokes */
RELATIONSHIP pokes FROM user TO MANY poke

/* But each poke can only be targeted to one user */
RELATIONSHIP poketarget FROM poke TO ONE user

/*
 * NOTE:
 * The wallposts/friendships/and pokes concepts all have the same
 * basic model.
 * QUESTION: Is it possible to do these many-to-many models without 
 *  creating an intermediate entity (represented by X above)? I don't
 *  expect so, because in a traditional RDBMS, you would have to do the
 *  same thing anyways, even if you wanted to store no metadata, you
 *  would at least need a join table
 */

/* -------- BEGIN QUERY DEFINITIONS --------- */
QUERY myNetworks
FETCH network OF user BY networks
WHERE user=[this]
ORDER BY type

QUERY postsOnMyWall
FETCH wallpost 
    OF user me BY wallpostsToUser
WHERE me=[this]
ORDER BY dateposted

QUERY myPostsOnOtherWalls
FETCH wallpost
    OF user me BY wallpostsFromUser
WHERE me=[this]
ORDER BY dateposted

/* NOTE: WallToWall(a,b) is then generated by calling this query twice
 * (i.e. myPostsOnUserWall(1:a,2:b) and then myPostsOnUserWall(1:b,2:a))
 * and interleaving them together by date
QUERY myPostsOnUserWall
FETCH wallpost
    OF user me BY wallPostsFromUser
    OF user other BY wallPostsToUser
WHERE 
    me.id = [1:myid] AND other.id = [2:otherid]

/* NOTE: We use the assumption that all approved friendships are 
 * bi-directional, ie if you are my friend then I am your friend 
 */
QUERY myFriends
FETCH user
    OF friendship BY target
    OF user me BY friendships
WHERE me=[this] AND friendship.approved = true

QUERY myFriendsInNetwork
FETCH user 
    OF friendship BY target
    OF user me BY friendships
    OF network nw BY networks
WHERE 
    me=[this] AND 
    nw=[1:network] AND 
    friendship.approved = true

QUERY pendingFriendRequests
FETCH user
    OF friendship BY friendships
    OF user me BY target
WHERE me=[this] AND friendship.approved = false

QUERY myGroups
FETCH group OF user BY groups
WHERE user=[this]

QUERY usersInGroup
FETCH user
    OF group BY groups
WHERE group=[this]

QUERY groupWall
FETCH wallpost
    OF group g BY wallpostsToGroup
WHERE g=[this]

QUERY myPokedBy
FETCH user
    OF poke BY pokes
    OF user me BY poketarget
WHERE me=[this] AND poke.hidden = false

/* 
 * Missing Queries 
 */
// 1) Friend's birthdays for today
// Need range predicates (ie date <= [time]) to do this, since we 
// are using ints to store dates

// 2) Friend count
// Need aggregates

// 3) Mutual Friends
// I'm not sure how we can do this with the current tools

// 4) Friends in my network
// How do we do this without any inner sub-queries?
