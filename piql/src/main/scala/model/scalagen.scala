package edu.berkeley.cs.scads.piql.parser

import scala.collection.jcl.Conversions._
import org.apache.log4j.Logger

import org.apache.avro.Schema
import org.apache.avro.Schema.Type


object ScalaGen extends Generator[BoundSpec] {
	val logger = Logger.getLogger("scads.scalagen")
	val autogenWarning = "/* This is an autogenerated scads spec file, do not modify it unless you know what you are doing */"
	val imports = Array("import edu.berkeley.cs.scads.model")

	protected def generate(spec: BoundSpec)(implicit sb: StringBuilder, indnt: Indentation): Unit = {
		/* Headers */
		output("/* This is an autogenerated scads spec file, do not modify it unless you know what you are doing */")
		output("import edu.berkeley.cs.scads.piql.{Entity, EntityPart}")
		output("import edu.berkeley.cs.scads.storage.ScadsCluster")
		output("import org.apache.avro.Schema")
		output("import org.apache.avro.util.Utf8")
		output("import org.apache.avro.specific.SpecificRecordBase")

		spec.entities.values.foreach(generate)
	}

	protected def generate(entity: BoundEntity)(implicit sb: StringBuilder, indnt: Indentation): Unit = {
		outputBraced("class ", entity.name, " extends Entity[", entity.name, ".KeyType", ",", entity.name, ".ValueType]") {
      output("val namespace = ", quote("ent_" + entity.name))
			def outputFields(r: Schema, prefix: String): Unit = {
				r.getFields.foreach(f => f.schema().getType match {
					case Type.STRING => output("var ", prefix + f.name, ":String = \"\"")
					case Type.BOOLEAN =>output("var ", prefix + f.name, ":Boolean = false")
					case Type.INT =>output("var ", prefix + f.name, ":Int = 0")
					case Type.RECORD => outputFields(f.schema, prefix + f.name)
				})
			}
			outputFields(entity.keySchema, "")
			outputFields(entity.valueSchema, "")

      def outputFunctions(r: Schema, prefix: Option[String]): Unit = {
				val fields = r.getFields.toList

        outputBraced("override def get(f: Int): Object =") {
          outputBraced("f match ") {
            fields.zipWithIndex.foreach {
              case (field: Schema.Field, idx: Int) if(field.schema.getType == Type.INT) =>
                output("case ", idx.toString, " => new java.lang.Integer(", prefix.getOrElse(""), field.name, ")")
              case (field: Schema.Field, idx: Int) if(field.schema.getType == Type.BOOLEAN) =>
                output("case ", idx.toString, " => boolean2Boolean(", prefix.getOrElse(""), field.name, ")")
              case (field: Schema.Field, idx: Int) if(field.schema.getType == Type.STRING) =>
                output("case ", idx.toString, " => new Utf8(", prefix.getOrElse(""), field.name, ")")
              case (field: Schema.Field, idx: Int) =>
                output("case ", idx.toString, " => ", prefix.getOrElse(""), field.name)
            }
            output("case _ => throw new org.apache.avro.AvroRuntimeException(\"Bad index\")")
          }
        }

        outputBraced("override def put(f: Int, v: Any): Unit =") {
          outputBraced("f match") {
            fields.zipWithIndex.foreach {
              case (field: Schema.Field, idx: Int) if(field.schema.getType == Type.INT) =>
                output("case ", idx.toString, " => ", prefix.getOrElse(""), field.name, " = v.asInstanceOf[java.lang.Integer].intValue")
              case (field: Schema.Field, idx: Int) if(field.schema.getType == Type.BOOLEAN) =>
                output("case ", idx.toString, " => ", prefix.getOrElse(""), field.name, " = v.asInstanceOf[java.lang.Boolean].booleanValue")
              case (field: Schema.Field, idx: Int) if(field.schema.getType == Type.STRING) =>
                output("case ", idx.toString, " => ", prefix.getOrElse(""), field.name, " = v.toString")
              case (field: Schema.Field, idx: Int) =>
            }
            output("case _ => throw new org.apache.avro.AvroRuntimeException(\"Bad index\")")
          }
        }
      }

      outputBraced("object key extends ", entity.name, ".KeyType") {
        outputFunctions(entity.keySchema, None)
      }
      outputBraced("object value extends ", entity.name, ".ValueType") {
        outputFunctions(entity.valueSchema, None)
      }

      val subparts: List[Schema.Field] = (entity.keySchema.getFields.toList ++ entity.valueSchema.getFields.toList).filter(_.schema.getType == Type.RECORD)
      subparts.foreach(p => {
        outputBraced("object ", p.name, " extends ", entity.name, ".", p.name, "Type") {
          outputFunctions(p.schema, Some(p.name))
        }
      })

      output("val indexes: Map[String, Schema] = null")
    }

    outputBraced("object ", entity.name) {
			def outputObjects(r: Schema, name: String, prefix: Option[String]) {
				val fields = r.getFields.toList
				fields.filter(_.schema.getType == Type.RECORD).foreach(f => outputObjects(f.schema, f.name, Some(prefix.getOrElse("") + f.name)))

				outputBraced("class ", prefix.getOrElse(name), "Type extends EntityPart") {
					output("def getSchema(): Schema = Schema.parse(\"\"\"", r.toString, "\"\"\")")
          output("def put(f: Int, v: Any): Unit = throw new java.lang.RuntimeException(", quote("unsupported"), ")")
          output("def get(f: Int): Object = throw new java.lang.RuntimeException(", quote("unsupported"), ")")
				}
			}

			outputObjects(entity.keySchema, "Key", None)
			outputObjects(entity.valueSchema, "Value", None)
		}
	}

	private def quote(string: String) = "\"" + string + "\""
}
