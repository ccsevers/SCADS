package edu.berkeley.cs.scads.avro.compiler

import java.util.{ArrayList, Collection => JCollection}
import java.io.File
import org.apache.avro.Schema
import org.apache.avro.Schema.{Type,Field}
import org.apache.avro.Schema.Field.Order
import org.apache.avro.Protocol

import scala.collection.mutable.HashMap
import scala.collection.jcl.Conversions 

import org.apache.log4j.Logger

object CompilerMain {
    def main(args: Array[String]):Unit = {
        val jsonFileName = args(0)
        val jsonFile = new File(jsonFileName)
        val protocol = Protocol.parse(jsonFile)
        new Compiler(protocol).compile
    }
}

case class UnsupportedFeatureException(val msg: String) extends RuntimeException

class Compiler(val protocol: Protocol) {
    private val logger = Logger.getLogger("Compiler")

    private val name = protocol.getName
    private val namespace = protocol.getNamespace
    private val schemas = protocol.getTypes 

    // base class for classes we will generate in compiler
    abstract class AvroClass(val className: String)

    // -- records and union interfaces -- //
    // this class is for all record objects defined in JSON
    case class AvroRecordClass(val schema: Schema) extends AvroClass(schema.getName)
    // this class is for all the union interfaces that need to be defined
    case class AvroUnionInterfaceClass(_className: String) extends AvroClass(_className)
    case class AvroFixedClass(_className: String) extends AvroClass(_className)

    // -- lists and maps contained within unions -- //
    // this class is for arrays that live within unions,
    case class AvroUnionListClass(val schema: Schema) extends AvroClass("UnionList")
    // this class is for maps that live within unions,
    case class AvroUnionMapClass(val schema: Schema) extends AvroClass("UnionMap")

    // --- primitives contained within unions --- //
    case object AvroIntClass extends AvroClass("AvroInt")
    case object AvroLongClass extends AvroClass("AvroLong")
    case object AvroFloatClass extends AvroClass("AvroFloat")
    case object AvroDoubleClass extends AvroClass("AvroDouble")
    case object AvroEnumClass extends AvroClass("AvroEnum")
    case object AvroBooleanClass extends AvroClass("AvroBoolean")
    case object AvroStringClass extends AvroClass("AvroString")
    case object AvroBytesClass extends AvroClass("AvroBytes")
    

    // Maps Record name (Class name) to a list of Union Interfaces
    // that it will have to implement. The keys in this map is the source
    // for all the classes that will be generated by the compiler
    private val classMap = new HashMap[AvroClass, List[AvroUnionInterfaceClass]]

    private val generator = new AvroCompilerGenerator

    class AvroCompilerGenerator extends Generator[AvroClass] {
        protected def generate(elm: AvroClass)(implicit sb: StringBuilder, indnt: Indentation):Unit = {
            elm match {
                case rec: AvroRecordClass => {
                    outputPartial("case class " + rec.className + " extends org.apache.avro.specific.SpecificRecordBase")
                    outputPartial(" with org.apache.avro.specific.SpecificRecord")
                    if (!classMap.get(rec).get.isEmpty)
                        outputPartial(" with ")
                    outputPartial(classMap.get(rec).get.map(_.className.trim).mkString(""," with ",""))
                    output(" {")
                    indent {
                        output("val SCHEMA$ = org.apache.avro.Schema.parse(\"" + rec.schema.toString.replaceAll("\"","\\\\\"") + "\")")
                        iterateRecordFields(rec.schema, (fieldName, field) => {
                            val fieldSchema = field.schema
                            fieldSchema.getType match { 
                                case Type.ARRAY => output("array")
                                case Type.BOOLEAN => 
                                    output("var " + fieldName + ":Boolean = false")
                                case Type.BYTES =>
                                    output("var " + fieldName + ":java.nio.ByteBuffer = null")
                                case Type.DOUBLE =>
                                    output("var " + fieldName + ":Double = 0.0")
                                case Type.ENUM => output("enum")
                                case Type.FLOAT =>
                                    output("var " + fieldName + ":Float = 0.0")
                                case Type.INT => 
                                    output("var " + fieldName + ":Int = 0")
                                case Type.LONG => 
                                    output("var " + fieldName + ":Long = 0")
                                case Type.MAP   => output("map")
                                case Type.NULL =>
                                    output("var " + fieldName + ":Object = null")
                                case Type.RECORD => 
                                    output("var " + fieldName + ":" + fieldSchema.getName + " = null")
                                case Type.STRING => 
                                    output("var " + fieldName + ":org.apache.avro.util.Utf8 = null")
                                case Type.UNION => 
                                    var unionInterfaceName = rec.schema.getName + "_" + fieldName + "_Iface"
                                    output("var " + fieldName + ":" + unionInterfaceName + " = null")
                            }
                        })
                        
                        output("override def get(field$: Int):Object = {")
                        indent {
                            output("field$ match {")
                            indent {
                                fieldsInOrder(rec.schema).foreach(field => {
                                    output("case " + field._2.pos + " => " + field._1) 
                                })
                            }
                            output("}")
                        }
                        output("}")

                        output("override def set(field$: Int, value$: Object):Unit = {")
                        indent {
                            output("field$ match {")
                            indent {
                                fieldsInOrder(rec.schema).foreach(field => {
                                    val str1 = "case " + field._2.pos + " => " + field._1 + " = value$.asInstanceOf[" 
                                    val str2 = field._2.schema.getType match {
                                        case Type.ARRAY => "array"
                                        case Type.BOOLEAN => "Boolean"
                                        case Type.BYTES => "java.nio.ByteBuffer"
                                        case Type.DOUBLE => "Double"
                                        case Type.ENUM => "enum"
                                        case Type.FLOAT => "Float"
                                        case Type.INT => "Int"
                                        case Type.LONG => "Long"
                                        case Type.MAP   => "map"
                                        case Type.NULL => "Object"
                                        case Type.RECORD => field._2.schema.getName 
                                        case Type.STRING => "org.apache.avro.util.Utf8"
                                        case Type.UNION => rec.schema.getName + "_" + field._1 + "_Iface"
                                    }
                                    output(str1+str2+"]") 
                                })
                            }
                            output("}")
                        }
                        output("}")
                    }
                    output("}")
                }
            } 
        }
    }

    private implicit def mkList[T](collection: JCollection[T]):List[T] = {
        val arrayList = new ArrayList[T]
        arrayList.addAll(collection)
        Conversions.convertList(arrayList).toList
    }

    private def issueWarning(warning: String) = {
        logger.warn(warning)
    }

    private def validate = {
        if (!protocol.getMessages.isEmpty)
            throw new UnsupportedFeatureException("Message constructs not yet supported")
    }

    def compile = {
        // Step 0: Validate
        validate

        // Step 1: Add all records to the class map
        schemas.foreach(schema => {
            schema.getType match {
                case Type.RECORD => 
                    classMap += AvroRecordClass(schema) -> List[AvroUnionInterfaceClass]()
            }
        })

        // Step 2: Resolve all union types
        schemas.foreach(schema => {
            schema.getType match {
                case Type.RECORD => preProcessRecord(schema)
                case _ => throw new UnsupportedFeatureException("Cannot handle: " + schema.getType) 
            } 
        })

        println(classMap)

        val sb = new StringBuilder
        sb.append("package ")
        sb.append(namespace)
        sb.append("\n\n")

        classMap.keys.filter(_.isInstanceOf[AvroRecordClass]).foreach(record => {
            sb.append(generator(record))
        })

        println(sb.toString)
    }

    private def fieldsInOrder(schema: Schema):List[(String,Field)] = {
        assert( schema.getType == Type.RECORD )
        Conversions.convertMap(schema.getFields).map(e => (e._1,e._2)).toList.sort(_._2.pos<_._2.pos)
    }

    private def iterateRecordFields(schema: Schema, closure: (String, Field) => Unit) = {
        assert( schema.getType == Type.RECORD )
        Conversions.convertMap(schema.getFields).foreach(entry => {
            val fieldName = entry._1 
            val field = entry._2 
            closure(fieldName, field)
        })
    }

    private def iterateUnionTypes(schema: Schema, closure: (Schema) => Unit) = {
        assert( schema.getType == Type.UNION )
        Conversions.convertList(schema.getTypes).toList.foreach(closure(_))
    }

    private def processRecord(schema: Schema) = {


    }

    private def preProcessRecord(schema: Schema) = {
        iterateRecordFields(schema, (fieldName, field) => {
            if (field.order != Order.IGNORE)
                issueWarning("Sort Order " + field.order + " will be ignored")
            val fieldSchema = field.schema
            if (fieldSchema.getType == Type.UNION) {
                val unionInterfaceName = schema.getName + "_" + fieldName + "_Iface"
                val unionInterfaceClass = AvroUnionInterfaceClass(unionInterfaceName)
                classMap +=  unionInterfaceClass -> List[AvroUnionInterfaceClass]()
                iterateUnionTypes(fieldSchema, (unionSchema) => {
                    unionSchema.getType match {
                        case Type.ARRAY  => 
                            addInterface(AvroUnionListClass(unionSchema.getElementType), unionInterfaceClass)
                        case Type.BOOLEAN =>
                            addInterface(AvroBooleanClass, unionInterfaceClass)
                        case Type.BYTES  =>
                            addInterface(AvroBytesClass, unionInterfaceClass)
                        case Type.DOUBLE  =>
                            addInterface(AvroDoubleClass, unionInterfaceClass)
                        case Type.FIXED  =>
                            addInterface(AvroFixedClass(unionSchema.getName), unionInterfaceClass)
                        case Type.FLOAT  =>
                            addInterface(AvroFloatClass, unionInterfaceClass)
                        case Type.INT  =>
                            addInterface(AvroIntClass, unionInterfaceClass)
                        case Type.LONG  =>
                            addInterface(AvroLongClass, unionInterfaceClass)
                        case Type.MAP  =>
                            addInterface(AvroUnionMapClass(schema.getValueType), unionInterfaceClass)
                        case Type.RECORD => 
                            addInterface(AvroRecordClass(unionSchema), unionInterfaceClass)
                        case Type.STRING =>  
                            addInterface(AvroStringClass, unionInterfaceClass)
                        case Type.UNION => 
                            throw new UnsupportedFeatureException("Cannot nest UNIONS yet")
                        case Type.NULL => { /* no op */ }
                    }
                }) 
            }
        })
    }

    private def addInterface(avroClass: AvroClass, avroIface: AvroUnionInterfaceClass) = {
        val list = classMap.get(avroClass).getOrElse(List[AvroUnionInterfaceClass]()) ::: List(avroIface)
        classMap += avroClass -> list
   }

}
